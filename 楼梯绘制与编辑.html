<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script type="text/javascript" src="./js/three.js"></script>
    <script type="text/javascript" src="./js/DragControls.js"></script>
    <script type="text/javascript" src="./js/OrbitControls.js"></script>
</head>

<body>
    <script type="text/javascript">
        const raycaster = new THREE.Raycaster();
        const pointer = new THREE.Vector2();
        let selectedObject = null;
        let selectedFace = null;
        let materialIndex = null;
        let hoverEnable = true;
        let objects = [];
        /**
        * 创建场景对象Scene
        */
        var scene = new THREE.Scene();
        var axes = new THREE.AxesHelper(3000);
        scene.add(axes);
        /**
         * 创建网格模型
         */
        // 负 x 轴方向的向量
        var v_x = new THREE.Vector3(-1, 0, 0);
        // 正 y 轴方向的向量
        var vy = new THREE.Vector3(0, 1, 0);
        // 负 z 轴方向的向量
        var v_z = new THREE.Vector3(0, 0, -1);
        // 第一个台阶网格模型
        var meshFirstStair = boxGeometry(260, 100, 1200, 0xff0000);
        meshFirstStair.translateOnAxis(vy, 50);
        // 第二个台阶网格模型
        var meshSecondStair = secondStair(600);
        meshSecondStair.translateOnAxis(v_x, 390);
        var group1 = new THREE.Group();
        // 剩余的台阶
        for (let i = 1; i < 16; i++) {
            let secondMesh = secondStair(600);
            secondMesh.translateOnAxis(v_x, 260 * i + 390).translateOnAxis(vy, 100 * i);
            group1.add(secondMesh);
        }
        // 平台的网格模型
        var meshPlatform = boxGeometry(1340, 150, 2500, '#80ffff');
        meshPlatform.translateOnAxis(v_x, 4960).translateOnAxis(vy, 1750).translateOnAxis(v_z, 650);
        group1.add(meshFirstStair, meshSecondStair, meshPlatform);
        // 井的网格模型
        var distance = boxGeometry(4420, 150, 100, '#0000b3');
        distance.translateOnAxis(v_x, 2080).translateOnAxis(vy, 1750).translateOnAxis(v_z, 650)
        // group2表示绕y轴旋转180度和调整后的group1
        var group2 = group1.clone().rotateY(Math.PI).translateOnAxis(v_z, -1300).translateOnAxis(v_x, -4160);
        var group = new THREE.Group();
        group.add(group1, distance, group2)
        scene.add(group)

        /**
         * 光源设置
         */
        //点光源
        var point = new THREE.PointLight(0xffffff);
        point.position.set(-800, 5000, 1000); //点光源位置
        scene.add(point); //点光源添加到场景中
        //环境光
        var ambient = new THREE.AmbientLight(0x444444);
        scene.add(ambient);
        /**
         * 相机设置
         */
        var width = window.innerWidth; //窗口宽度
        var height = window.innerHeight; //窗口高度
        var k = width / height; //窗口宽高比
        var s = 4000; //三维场景显示范围控制系数，系数越大，显示的范围越大
        //创建相机对象
        var camera = new THREE.OrthographicCamera(-s * k, s * k, s, -s, 0.1, 20000);
        camera.position.set(4000, 1300, 5500); //设置相机位置
        camera.lookAt(scene.position); //设置相机方向(指向的场景对象)
        /**
         * 创建渲染器对象
         */
        var renderer = new THREE.WebGLRenderer();
        renderer.setSize(width, height);//设置渲染区域尺寸
        renderer.setClearColor(0xb9d3ff, 1); //设置背景颜色
        document.body.appendChild(renderer.domElement); //body元素中插入canvas对象
        //封装渲染操作   指定场景、相机作为参数
        function render() {
            renderer.render(scene, camera);
        }
        function animate() {
            requestAnimationFrame(animate);
            render();
        }
        animate()

        
        // OrbitControls
        var orbitControls = new THREE.OrbitControls( camera, renderer.domElement );
		orbitControls.listenToKeyEvents( window );
        // DragControls
        dragControls = new THREE.DragControls(objects, camera, renderer.domElement);
        dragControls.addEventListener('drag', render);


        // 事件监听
        window.addEventListener('resize', onWindowResize);
        document.addEventListener('pointermove', onPointerMove);
        document.addEventListener('dblclick', ondblclick);


        // 立方体几何
        function boxGeometry(x, y, z, materialColor) {
            // 采用 BoxGeometry 立方体几何
            var geometry = new THREE.BoxGeometry(x, y, z);
            let mats = []
            var material1 = new THREE.MeshLambertMaterial({
                color: materialColor,
                side: THREE.DoubleSide,
            });
            var material2 = new THREE.MeshLambertMaterial({
                color: materialColor,
                side: THREE.DoubleSide,
            });
            var material3 = new THREE.MeshLambertMaterial({
                color: materialColor,
                side: THREE.DoubleSide,
            });
            var material4 = new THREE.MeshLambertMaterial({
                color: materialColor,
                side: THREE.DoubleSide,
            });
            var material5 = new THREE.MeshLambertMaterial({
                color: materialColor,
                side: THREE.DoubleSide,
            });
            var material6 = new THREE.MeshLambertMaterial({
                color: materialColor,
                side: THREE.DoubleSide,
            });
            mats.push(material1)
            mats.push(material2)
            mats.push(material3)
            mats.push(material4)
            mats.push(material5)
            mats.push(material6)
            // 返回网格模型对象Mesh
            mesh = new THREE.Mesh(geometry, mats);
            mesh.name = materialColor
            return mesh
        }
        // 楼梯二阶,梯形立方体
        function secondStair(distance) {
            // 描述楼梯的梯形侧面轮廓对象
            var shape = new THREE.Shape();
            shape.moveTo(260, 0);
            shape.lineTo(260, 200);
            shape.lineTo(0, 200);
            shape.lineTo(0, 100);
            shape.lineTo(260, 0);

            var extrudeSettings = {
                steps: 2,
                depth: 1200,
                bevelEnabled: false,
            };
            // 采用挤压几何体 ExtrudeBufferGeometry
            var geometry = new THREE.ExtrudeBufferGeometry(shape, extrudeSettings);
            let mats = []
            var material1 = new THREE.MeshLambertMaterial({
                color: 0xff0000,
                side: THREE.DoubleSide,
            });
            var material2 = new THREE.MeshLambertMaterial({
                color: 0xff0000,
                side: THREE.DoubleSide,
            });
            mats.push(material1)
            mats.push(material2)
            var mesh = new THREE.Mesh(geometry, mats);
            // 调整几何体的z轴
            mesh.translateOnAxis(v_z, distance);
            mesh.name = '#f00'
            return mesh;
        }

        // 窗口大小改变重设渲染大小
        function onWindowResize() {

            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize(window.innerWidth, window.innerHeight);

        }
        // 鼠标hover效果
        function onPointerMove(event) {
            if (hoverEnable) {
                if (selectedObject) {
                    // 把选中对象改为非选中状态，把选中对象清除
                    selectedObject.material[materialIndex].color.set(selectedObject.name)
                    selectedObject = null;
                }
                // 将鼠标位置归一化为设备坐标。x 和 y 方向的取值范围是 (-1 to +1)
                pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
                pointer.y = - (event.clientY / window.innerHeight) * 2 + 1;
                // 通过摄像机和鼠标位置更新射线
                raycaster.setFromCamera(pointer, camera);

                const intersects = raycaster.intersectObject(group, true);
                if (intersects.length > 0) {
                    const res = intersects.filter(function (res) {
                        return res && res.object;
                    })[0];
                    if (res && res.object) {
                        // 选中的几何体对象
                        selectedObject = res.object
                        // 改变选中的几何体的面的颜色
                        materialIndex = res.face.materialIndex
                        selectedObject.material[materialIndex].color.set('#fff')
                    }
                }
            }
        }
        // 鼠标点击拖拽几何体
        function ondblclick(event) {
            // 点击非几何体区域把鼠标悬停改变颜色和 OrbitControls 打开
            hoverEnable = true
            orbitControls.enabled = true
            if (selectedObject) {
                // 把选中对象改为非选中状态，把选中对象清除
                selectedObject.material.forEach(items => {
                    items.color.set(selectedObject.name)
                })
                selectedObject = null;
            }
            // 将鼠标位置归一化为设备坐标。x 和 y 方向的取值范围是 (-1 to +1)
            pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
            pointer.y = - (event.clientY / window.innerHeight) * 2 + 1;
            // 通过摄像机和鼠标位置更新射线
            raycaster.setFromCamera(pointer, camera);

            const intersects = raycaster.intersectObject(group, true);
            if (intersects.length > 0) {
                const res = intersects.filter(function (res) {
                    return res && res.object;
                })[0];
                if (res && res.object) {
                    // 选中的几何体对象
                    selectedObject = res.object;
                    // 改变选中的几何体的面的颜色
                    materialIndex = res.face.materialIndex
                    selectedObject.material.forEach(items => {
                        items.color.set('#fff')
                    })
                    // 关闭鼠标悬停效果和 OrbitControls 功能
                    hoverEnable = false
                    orbitControls.enabled = false
                    // 把选中对象传入给 DragControls 的操作数组
                    objects.push(selectedObject)
                    console.log(res.face)
                    console.log(selectedObject)
                }
            }
        }
    </script>
</body>

</html>